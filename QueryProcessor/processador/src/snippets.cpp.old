#include "snippets.h"

char tblAcento[128];

//inicia tabela de acentos
void iniciaTblAcento()
{
    tblAcento[0] = tblAcento[1] = tblAcento[2] = tblAcento[3] = tblAcento[4] = tblAcento[5] = tblAcento[6] = 'a';
    tblAcento[7] = 'c';
    tblAcento[8] = tblAcento[9] = tblAcento[10] = tblAcento[11] = 'e';
    tblAcento[12] = tblAcento[13] = tblAcento[14] = tblAcento[15] = 'i';
    tblAcento[16] = ' ';	// 'Ð' Eh descartado
    tblAcento[17] = 'n';	
    tblAcento[18] = tblAcento[19] = tblAcento[20] = tblAcento[21] = tblAcento[22] = 'o';
    tblAcento[23] = ' ';	// '×' Eh descartado
    tblAcento[24] = ' ';	// 'Ø' Eh descartado
    tblAcento[25] = tblAcento[26] = tblAcento[27] = tblAcento[28] = 'u';
    tblAcento[29] = 'y';
    tblAcento[30] = ' ';	// '×' Eh descartado
    tblAcento[31] = ' ';	// 'Ø' Eh descartado	
    tblAcento[32] = tblAcento[33] = tblAcento[34] = tblAcento[35] = tblAcento[36] = tblAcento[37] = tblAcento[38] = 'a';
    tblAcento[39] = 'c';
    tblAcento[40] = tblAcento[41] = tblAcento[42] = tblAcento[43] = 'e';
    tblAcento[44] = tblAcento[45] = tblAcento[46] = tblAcento[47] = 'i';
    tblAcento[48] = ' ';	// 'ð' Eh descartado
    tblAcento[49] = 'n';
    tblAcento[50] = tblAcento[51] = tblAcento[52] = tblAcento[53] = tblAcento[54] = 'o';
    tblAcento[55] = ' ';	// '÷' Eh descartado
    tblAcento[56] = ' ';	// 'ø' Eh descartado
    tblAcento[57] = tblAcento[58] = tblAcento[59] = tblAcento[60] = 'u';
    tblAcento[61] = 'y';
    tblAcento[62] = ' ';	// 'þ' Eh descartado
    tblAcento[63] = 'y';	
}

//limpa acentos de uma string
__inline void LimpaAcento(char *txt)
{
    int i  = 0;
    int cn = 0;
    int tam = strlen(txt);

    for(i=0; i<tam; i++){
	if((txt[i]>0)){	//Caracteres entre 0 e 127. sem acento 
	    if((txt[i]<48) || (txt[i]>122) || (txt[i]>57 && txt[i]<65)|| (txt[i]>90 && txt[i]<97)){	//Chars Especiais
		if(txt[i-1]!=' '){			//Veirifica se jah foi existe um espaco antes
		    txt[cn] = ' ';
		    cn++;
		}
	    }else if(txt[i]>64 && txt[i]<91){		//Caso a letra seja maiuscula entao ela es passada para minuscula
		txt[cn] = txt[i]+32;			//toLower somando 32
		cn++;
	    }else{						//A letra jah eh muniscula
		txt[cn] = txt[i];
		cn++;
	    }
	}else	if(txt[i] == -61){				//Caso seja caracter acentuado
	    txt[cn] = tblAcento[txt[i+1]+128];		//Soma com 128 para obter o char da posicao da tbl de Acentos
	    cn++;
	    i++;						//Pula um char pois o prox eh desnecessario tbm		
	}else	if(txt[i] == -62){				//Caso seja caracter especial desnecessario a indexacao
	    txt[cn] = ' ';
	    cn++;
	    i++;						//Pula um char pois o prox eh desnecessario tbm
	}
    }
    txt[cn] = 0;							//Indica o novo final da string txt
}

//algoritmo de insercao
void insercao(int* vet, int tam) 
{
    int i, j, elem;	

    i = 1;
    while (i < tam) {
	elem = vet[i];
	j = i-1;
	while ((j >= 0 ) && (elem < vet[j])) {
	    vet[j+1] = vet[j];
	    j--;
	}
	vet[j+1] = elem;
	i++;
    }	
}

//Faz parse dos elementos da query
void strParseTermos(char *query, char **termos)
{
    int i, j, k, pos;
    char termo[MAXTAMCONSULTA];

    pos = 0;
    while((query[pos] == ' ')&&(query[pos] != '\0')) pos++;

    i = 0; j = 0; k = 0;
    while(query[pos] != '\0') {
	if((query[pos] == ' ')&&(j == 1)) {
	    termo[i] = '\0';
	    strcpy(termos[k], termo);	    		
	    j = 0; i = 0;
	    ++pos; ++k;
	}
	else if (!(((query[pos]>=65)&&(query[pos]<=90))||((query[pos]>=97)&&(query[pos]<=122))||((query[pos]>=48)&&(query[pos]<=57))||(query[pos]<0))) {
	    ++pos;
	}
	else {
	    termo[i] = query[pos];
	    j = 1;
	    ++pos; ++i;
	}
    }

    if(j == 1) {
	termo[i] = '\0';
	strcpy(termos[k], termo);
    }

    return;
}

//Recupera o primeiro Token da string
__inline int getFirstToken(char *str1, char *str2)
{
    int i;

    i = 0;
    while(((str1[i]>=65)&&(str1[i]<=90))||((str1[i]>=97)&&(str1[i]<=122))||((str1[i]>=48)&&(str1[i]<=57))||(str1[i]<0)&&(str1[i]!=0)) i++;

    strncpy(str2, str1, i);
    str2[i] = '\0';

    if(str1[i] == '\0') return -1;

    return i;
}

//Passa os caracteres da string para minusculas
__inline void minusculas(char* str) 
{
    int i, tam;

    tam = strlen(str);
    for (i = 0; i < tam; i++) {
	if ((str[i] >= 65) && (str[i] <= 90)) {
	    str[i] +=32;
	}
    }
}

//Encontra a posicao de str2 em str1
char *strPosTermo(char *str1, char *str2)
{
    int pos, i;
    char token[MAXTAMCONSULTA], termo[MAXTAMCONSULTA];

    iniciaTblAcento();

    strcpy(termo, str2);
    LimpaAcento(termo);
    minusculas(termo);
    pos = 0;
    while(str1[pos] != '\0') {

	while(!(((str1[pos]>=65)&&(str1[pos]<=90))||((str1[pos]>=97)&&(str1[pos]<=122))||((str1[pos]>=48)&&(str1[pos]<=57))||(str1[pos]==-61))&&(str1[pos]!= 0)) pos++;

	i = getFirstToken(&str1[pos], token);
	LimpaAcento(token);
	minusculas(token);	
	if(!strcmp(termo, token)) return &str1[pos];
	pos += i;
	if(i == -1) return NULL;
    }

    return NULL;
}


//Elimina partes do documento que não são o conteúdo do documento
//Revisar
int getContent(char *doc)
{
    char *linha;
    char *content1;
    int i, j, pos, first, token;
    unsigned int n, size;

    size = strlen(doc);
    //fprintf(stderr, "Tam Doc: %d\n", size);
    if(size) content1 = (char *) malloc(sizeof(char)*(size+1));
    else return 0;

    linha = (char *) malloc(sizeof(char)*(size+1));

    if(!content1 || !linha) {
	fprintf(stderr, "Erro ao alocar memoria.\n");
	return 0;
    }

    content1[0] = '\0';
    pos = 0; j = 0; first = 1; n = 1;
    while((doc[pos] != '\0') && (n <= size) &&(size > 0)) {
	i = 0; token = 0;
	linha[i] = '\0';

	//ignora espaços em branco, tabulações e quebra de linha
	while((doc[pos] == ' ') || (doc[pos] == '\t') || (doc[pos] == '\n')) {
	    if((n == size) || (doc[pos] == '\0')) break;
	    pos++;n++;
	}

	//recupera uma linha
	while((doc[pos] != '\n') && (doc[pos] != '\0') && (n <= size)) {
	    if(doc[pos] == '\0') break;			
	    if(doc[pos] == '[') {
		while((doc[pos] != ']')&&(doc[pos]!='\0')) { 
		    n++; 
		    pos++;
		}

		pos++;n++;
	    } 
	    else {
		if((doc[pos] == ' ') && (doc[pos-1]) != ' ') token++;
		linha[i] = doc[pos];
		pos++; n++;
		//verifica se o caractere recuperado não é um espaço ou /n
		if((linha[0] != ' ')&&(linha[0] != '\n')) i++;
	    }
	}
	pos++; n++;
	linha[i] = '\n'; linha[i+1] = '\0';
	if(((linha[0] != '\0') || (linha[0] != '\n')) && (token > 4)) { //se a linha tiver mais que 4 tokens grava no 'content'
	    strcpy(&content1[j], linha);
	    j += i+1;
	}
    }
    content1[j] = '\0';
    //	fprintf(stderr, "%s\n", doc);
    //	getchar();
    //	fprintf(stderr, "%s\n", content1);
    //	getchar();
    //strcpy(doc, content1);//faz com que o 'content' vire o documento a ser utilizado para os snippets

    if(size >= strlen(content1)){
	strcpy(doc, content1);
	free(content1);
	free(linha);
	return size;
    }
    else{
	content1[0] = '\0';
	free(content1);
	free(linha);
	return 0;
    }

}

//Recupera os snippets
char * getSnippet(char *content, char *query)
{
    int i, j, n, nTermos, size;
    int *posTermos;
    char *pch, *inicio, **termos, *snippet;
    char token[MAXTAMCONSULTA];

    //Elimina "lixos" do documento
    size = getContent(content); 
    //Aloca memória para snippet
    snippet = (char*) malloc(sizeof(char)*MAXTAMTRECHO*10);
    snippet[0] = '\0';

    if(!size) return snippet;
    //fprintf(stderr, "marco 1 - getContent ok\n");

    //Procedimento abaixo é para contagem dos termos da query
    i = 0;
    while((query[i] == ' ')&&(query[i] != '\0')) i++;

    nTermos = 0; j = 0;
    while(query[i] != '\0') {
	if((query[i] == ' ')&&(j == 1)) {
	    j = 0;
	    ++nTermos;
	    ++i;
	}
	else if(!(((query[i]>=65)&&(query[i]<=90))||((query[i]>=97)&&(query[i]<=122))||((query[i]>=48)&&(query[i]<=57))||(query[i]<0))) {
	    ++i;
	}
	else {
	    j = 1;
	    ++i;
	}
    }

    if(j == 1) ++nTermos;

    //Aloca vetores que irão conter os termos da query e suas respectivas posições nos snippets
    if(nTermos) {
	posTermos = (int*) malloc(sizeof(int)*nTermos);
	termos = (char**) malloc(sizeof(char*)*nTermos);

	//fprintf(stderr, "Num Termos: %d || Query: %s\n",nTermos, query);
	for(i = 0; i < nTermos; i++) {
	    termos[i] = (char *) malloc(sizeof(char)*MAXTAMCONSULTA*10);
	    posTermos[i] = -1;
	}

	//Faz o parse da query e coloca os tokens no vetor de termos
	strParseTermos(query, termos);

//	for(i = 0; i < nTermos; i++) fprintf(stderr, "Termos %d: %s || ",i, termos[i]);
	//fprintf(stderr, "\nmarco 2 - Parser da Query ok\n");
    }

    //Localiza os termos no documento
    for(i = 0; i < nTermos; i++) {
	pch = strPosTermo(content, termos[i]);
	if(pch) {
	    posTermos[i] = pch - content;
	   // fprintf(stderr, "Termo: %s Pos Doc: %d Pos Mem: %p\n",termos[i], posTermos[i], pch);
	}
    }

    //Ordena as posicoes dos termos encontrados no documento
    insercao(posTermos, nTermos);

    //for(i = 0; i < nTermos; i++) fprintf(stderr, "Posicao Str: %d || ", posTermos[i]);

    //fprintf(stderr, "\nMarco 3 - Localização do Termos completo\n");

    //verifica quantos termos não existem no documento
    i = 0;
    while((i < nTermos) && (posTermos[i] == -1)) i++;

    //verifica se no máximo houve um termo encontrado no documento e extrai o snippet	
    if(((nTermos - i) <= 1)&&(size > 30)) { 
	if(i == nTermos) --i;//verifica se não há termos no documento

	if(nTermos) j = posTermos[i] - 30;
	if(j < 0){//verifica a distancia do primeiro termo encontrado ao inicio do documento 
	    j = 0;
	    inicio = content;
	}
	else inicio = strstr(&content[j], " ");//rever funcao utilizada	    
	//fprintf(stderr, "Snippet->Doc: %p\n",inicio);
	j = 0; n = 0; snippet[0]= '\0';
	while((inicio[j] != '\0') && (n <= 20)) {
	    //Ignora caracteres especiais
	    while(!(((inicio[j]>=65)&&(inicio[j]<=90))||((inicio[j]>=97)&&(inicio[j]<=122))||((inicio[j]>=48)&&(inicio[j]<=57))||(inicio[j]==-61))&&(inicio[j]!='\0')) j++;
	    i = getFirstToken(&inicio[j],token);
	    if(i == -1) {
		break;
	    } 
	    j += i;
	    n++;
	    strcat(snippet, token);
	    strcat(snippet, " ");
	    if(j > 200) break;
	}

	if(snippet[0] != '\0') strcat(snippet, "...");
    } 
    else if(size > 30) {
	int tam,k;
	/*int numIt, redutor, dif, k;
	  redutor = 0; 
	  if(nTermos - i > 3) dif = 50;
	  else dif = 75;
	  numIt =  0;
	  while(numIt  < 3) {
	  k = nTermos - 1;
	  while((k < nTermos) && (k > i) && (redutor < 150) && !(posTermos[k] - posTermos[i] <= (150-redutor))) {
	  k--;
	  redutor += dif;
	  }*/
	//fprintf(stderr,"%d %d %d\n", numIt, 150/dif, redutor); 
	if((posTermos[i] - posTermos[nTermos -1]) < 350){ 
	    tam = 350;
	    k=1;
	}
	else {
	    tam = 150;
	    k = 2;
	}
	snippet[0] = '\0';
	for(;--k;) {
	    if(nTermos) j = posTermos[i] - 30;
	    if(j < 0){//verifica a distancia do primeiro termo encontrado ao inicio do documento 
		j = 0;
		inicio = content;
	    }
	    else inicio = strstr(&content[j], " ");//rever funcao utilizada     
	    //fprintf(stderr, "Snippet->Doc: %p\n",inicio);
	    j = 0; n = 0; 
	    while((inicio[j] != '\0') && (n <= 20)) {
		//Ignora caracteres especiais
		while(!(((inicio[j]>=65)&&(inicio[j]<=90))||((inicio[j]>=97)&&(inicio[j]<=122))||((inicio[j]>=48)&&(inicio[j]<=57))||(inicio[j]==-61))&&(inicio[j]!='\0')) j++;
		i = getFirstToken(&inicio[j],token);
		if(i == -1) {
		    break;
		}
		j += i;
		n++;
		strcat(snippet, token);
		strcat(snippet, " ");
		if(j > tam) break;
	    }
	    if(snippet[0] != '\0') strcat(snippet, "...");
	    //numIt++; i = k+1;
	    //if(i >= nTermos) break;
	    i = nTermos - 1;
	}
    }

    if(nTermos) {
	free(posTermos);
	for(i = 0; i < nTermos; i++) free(termos[i]);
	free(termos);
    }

    return snippet;
    }
